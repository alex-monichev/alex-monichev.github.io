<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Notes</title>
    <link rel="stylesheet" href="js-notes-style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- and it's easy to individually load additional languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>

<script>hljs.highlightAll();</script>
</head>
<body>
    <img
        id="theme-toggle"
        class="icon"
        src="icons/light-mode.png"
        alt="Color theme icon"
        src-light="icons/light-mode.png"
        src-dark="icons/dark-mode.png">
    <script src="js-notes-script.js"></script>
    <div>
        <h1>Variables</h1>
        <p>Variable allows <strong>repeated</strong> access to <strong>values</strong></p>

        <h2>How to Name Variables</h2>
        <ul>
        <li><strong><u>P</u>ascal<u>C</u>ase</strong>: used for <strong>Types</strong> and <strong>Classes</strong>.</li>
        <li><strong>DB_PASSWORD</strong>: used for values <strong>known before the launch</strong> of an app/program and are <strong>unchangable</strong>.</li>
        <li><strong><u>c</u>amel<u>C</u>ase</strong>: used for <strong>variables</strong></li>
        </ul>

        <p>Variable names should be <strong>understandable</strong>. (Bad examples: <del>foo, bar, test, xyz</del>)</p>

        <h2>Type system</h2>
        <ul>
        <li><strong>Static</strong> - Variable type is determined in code with <em>keywords</em> and <strong>is checked by compiler</strong>. Languages that use Static typing: <strong>C++, C, Java</strong></li>
        <li><strong>Dynamic</strong> - Variable type is determined by its <em>value</em> in the <strong>moment of code execution</strong>. Languages that use Dynamic typing: <strong>JS, Python</strong></li>
        </ul>

        <h2>Object Types</h2>

        <h3>Primitive Types</h3>
        <p>These types are stored <strong>directly in the variable</strong> and hold their actual values. When you assign a primitive type to a variable, it contains the value itself. If you copy a primitive value to another variable, you create a separate copy.</p>
        <p>These types are:</p>
        <ul>
        <li>String</li>
        <li>Boolean</li>
        <li>Number</li>
        <li>Null</li>
        <li>Undefined</li>
        <li>Symbol</li>
        </ul>

        <h3>Reference Types</h3>
        <p>These types are stored <strong>as references to their values</strong>. When you assign a reference type to a variable, the variable holds a reference (or a pointer) to the location in memory where the value is stored. If you <em>copy</em> a reference type to another variable, <strong>both variables point to the same object in memory</strong>.</p>
        <p>These types are:</p>
        <ul>
        <li>Object</li>
        <li>Array</li>
        <li>Function</li>
        </ul>

        <h2>Variable initializing</h2>
        <table>
        <tr>
            <th><code>let</code></th>
            <th><code>const</code></th>
            <th class="wrong"><code>var</code></th>
        </tr>
        <tr>
            <td>Modifiable</td>
            <td>Constant</td>
            <td class="wrong">Modifiable, <b>not used</b></td>
        </tr>
        </table>

        <p>There're two ways to initialize a variable:</p>
        <ul>
        <li><strong>Initializing</strong> (<code>let a</code>): permitted only for modifiable variables.</li>
        <li><strong>Initializing and assigning</strong> (<code>const c=10</code>): the only way to initialize a constant variable. If tried to use only <strong>initializing</strong>, it will throw a <code>SyntaxError: Missing initializer in const declaration.</code></li>
        </ul>
        <hr>
    </div>
    <div>
        <h1>Objects</h1>

        <p>In JavaScript, Objects are a <em>fundamental data structure</em> and a key part of the language. Objects are used to represent complex data structures. They can be <strong>used for everything</strong> from simple data containers to more complex entities (like functions, arrays, and even custom types).</p>
        
        <h2>Objects can be</h2>
        
        <ul>
            <li><h3>Collections of key-value pairs</h3>
                <p>Objects are collections of <strong>key-value</strong> pairs, where each key is a property name, and each value can be any data type (e.g., numbers, strings, functions, or even other objects). The <strong>syntax</strong> is: <code>propertyName: propertyValue</code></p>
            </li>
            <li><h3>Almost all things in JS</h3>
                <p>In JavaScript, <strong><em>nearly everything</em></strong> that isn’t a primitive type is an object (e.g., arrays, functions, dates, and even errors). Objects are flexible and form the foundation of many JavaScript features.</p>
            </li>
            <li><h3>Reference Type variables</h3>
                <p>Objects are a type of reference variable. Unlike primitive data types, which store their values directly, objects store a reference to the location in memory where the data is kept. This means that when you assign or copy an object, you’re working with references to the same data.</p>
            </li>
        </ul>
        
        <h2>Object Creation</h2>
        
        <p>Object can be made through:</p>
        
        <ul>
            <li><h3>Object Literal <code>{}</code></h3>
                <p>The <strong>simplest and most common way</strong> to create an object is by using object literal syntax.</p>
                <p><strong>Syntax:</strong></p>
                <pre><code>let objectName = {
    property1: value1,
    property2: value2
};</code></pre>
            </li>
            <li><h3><code>new</code></h3>
                <p>This approach is less common but useful if you’re <strong>dynamically adding properties</strong> after creating the object.</p>
                <p><strong>Syntax:</strong></p>
                <pre><code>let objectName = new Object();</code></pre>
            </li>
        </ul>
        
        <p>There're more ways to make an Object, but these are most common in JS.</p>
        
        <p><strong>Order of elements in an Object <em>doesn't</em> matter</strong></p>
        
        <h2>Accessing Object Properties</h2>
        
        <p>In JavaScript, you can access and interact by <strong>adding</strong>, <strong>editing</strong> or <strong>removing</strong> an object's properties using two main syntaxes: <strong>Dot Notation</strong> and <strong>Bracket Notation</strong>. Each has its own use cases and advantages.</p>
        
        <h3>Dot Notation</h3>
        
        <p>Dot Notation is the simpler and more common way to access properties. It's <strong>straightforward and visually cleaner</strong>, making code easy to read.</p>
        
        <h4>Pros:</h4>
        <ul>
            <li>Dot notation is best when you know the <strong>exact name of the property</strong> and it follows standard variable naming rules (e.g., it doesn’t start with a number and <strong>contains no spaces or special characters</strong>).</li>
            <li>It’s generally preferred <strong>when you have control over the property names</strong> because it’s more <em>concise</em> and <em>readable</em>.</li>
        </ul>
        
        <h4>Cons:</h4>
        <ul>
            <li>Dot notation cannot be used if:
                <ul>
                    <li>The property name contains <strong>spaces</strong> (<code>person["first name"]</code>).</li>
                    <li>The property name starts with a <strong>number</strong> (<code>person["123name"]</code>).</li>
                    <li>The property name is stored in a <strong>variable</strong> and <strong>not known ahead of time</strong>.</li>
                </ul>
            </li>
        </ul>
        
        <h3>Bracket Notation</h3>
        
        <p>Bracket Notation is more versatile, allowing you to access properties using dynamic expressions or property names that <strong>don’t follow standard naming conventions</strong>.</p>
        
        <h4>Pros:</h4>
        <ul>
            <li>Bracket notation is flexible and <strong>allows access to properties with names that contain spaces, special characters, or numbers</strong> (e.g., <code>person["first name"]</code> or <code>person["123name"]</code>).</li>
            <li>It is ideal for <strong>dynamic property access</strong>, where the property name might be stored in a variable or created at runtime.</li>
            <li>Useful when iterating over an object's properties with a loop, especially if property names are not known ahead of time.</li>
        </ul>
        
        <h4>Cons:</h4>
        <ul>
            <li>Bracket notation can be <strong>less concise and readable</strong> than dot notation, especially when accessing simple properties.</li>
            <li>It’s <strong>more prone to errors</strong> if the property name in quotes is misspelled, as there’s <strong>no auto-completion support</strong> in many editors.</li>
            <li>Requires <strong>explicit quotation marks</strong> around property names, which can sometimes make the code look cluttered.</li>
        </ul>
        
        <h3>Summary</h3>
        
        <table border="1">
            <tr>
                <th>Feature</th>
                <th>Dot Notation</th>
                <th>Bracket Notation</th>
            </tr>
            <tr>
                <td>Simple Syntax</td>
                <td>✅</td>
                <td>❌</td>
            </tr>
            <tr>
                <td>Dynamic Access</td>
                <td>❌</td>
                <td>✅</td>
            </tr>
            <tr>
                <td>Special Characters</td>
                <td>❌</td>
                <td>✅</td>
            </tr>
            <tr>
                <td>Variable Properties</td>
                <td>❌</td>
                <td>✅</td>
            </tr>
        </table>
        
        <h2>Interacting with Object Properties</h2>
        
        <p>Here's an example object:</p>
        
        <pre><code>const myCity = {
    city: 'New York',
    popular: true,
}</code></pre>
        
        <h3>Adding</h3>
        
        <p>To add a new property to an object, use either dot notation or bracket notation. If the property doesn’t already exist, it will be added to the object.</p>
        
        <pre><code>// dot notation
myCity.country = 'USA'
// bracket notation
myCity['country'] = 'USA'
console.log(myCity) // Output: { city: "New York", popular: true, country: 'USA' }</code></pre>

        <p><em>Properties are placed in the order in which they were added, unless they are assigned by numbers:</em></p>
        
        <pre><code>let example = {};
example.b = "second";
example.a = "first";
example[2] = "number two";
example[1] = "number one";

console.log(example); // { 1: "number one", 2: "number two", b: "second", a: "first" }</code></pre>
        
        <h3>Editing</h3>
        
        <p>Editing a property's value is the same as adding it — if the property already exists, <strong>assigning a new value will update it</strong>.</p>
        
        <pre><code>// dot notation
myCity.city = 'Las Vegas'
// bracket notation
myCity['city'] = 'Las Vegas'
console.log(myCity) // Output: { city: "Las Vegas", popular: true, country: 'USA' }</code></pre>
        
        <h3>Deleting</h3>
        
        <p>To remove a property, <strong>use the <code>delete</code> operator</strong>, followed by dot notation or bracket notation. This will permanently <strong>remove the property from the object</strong>.</p>
        
        <pre><code>// dot notation
delete myCity.country
// bracket notation
delete myCity['country']
console.log(myCity) // Output: { city: "Las Vegas", popular: true }</code></pre>
        
        <h3>Use of variables</h3>
        
        <p>If there're variables outside the object that have <strong>exact same name as your property, it can be simplified</strong>.</p>
        
        <p>Instead of this:</p>
        
        <pre><code>const name = 'Alex'
const postsQty = 23
        
const userProfile = {
    name: name,
    postsQty: postsQty
}</code></pre>
        
        <p>It can be written as:</p>
        
        <pre><code>const userProfile = { name, postsQty }</code></pre>
        
        <h3>Nested Objects</h3>
        
        <p>You can create objects inside other objects to build a structure.</p>
        
        <pre><code>const userProfile = {
    name: 'Alex',
    address: {
        street: '123 Main St',
        city: 'Somewhere'
        }
};

console.log(userProfile.address.city) // Output: 'Somewhere'</code></pre>
        
    </div>
    <div>
        <h1>Global Objects</h1>

    <p>In JavaScript, global objects are objects that provide a <strong>global scope</strong> where properties, functions, and variables can be accessed from anywhere in the code. The global object <strong>varies depending on the environment</strong> (like a web browser or Node.js). Here’s a look at the main global objects and how they work:</p>

    <h2><code>window</code></h2>

    <p><strong>In web browsers</strong>, the global object is called <code>window</code>. It <strong>represents the browser's window</strong> in which your script runs. The window object provides a range of properties and methods for <strong>controlling the browser, interacting with the Document Object Model (DOM), and accessing global variables and functions.</strong></p>

    <h2><code>global</code></h2>

    <p><strong>In Node.js</strong>, the global object is called <code>global</code>. Unlike browsers, <strong>Node.js does not have a window object</strong>. The global object in Node.js has similar functionality, allowing you to <strong>define variables, functions, or classes that should be accessible across the entire environment.</strong></p>

    <h2><code>globalThis</code></h2>

    <p>Introduced in <strong>ECMAScript 2020</strong>, <code>globalThis</code> provides a <strong>universal</strong> way to access the global object <strong>across different environments</strong> (like browsers, Node.js, and others). <code>globalThis</code> refers to the global object regardless of where the code runs, making it a more standardized way to write cross-platform JavaScript.</p>

    <p>Using <code>globalThis</code> is particularly helpful <strong>when writing code that runs in both browsers and Node.js</strong>, as it provides a consistent way to access the global scope across different environments.</p>

    <h2>Properties</h2>

    <p>It is possible to call properties of global objects <strong>without needing to use dot notation with <code>window</code>, <code>global</code>, or <code>globalThis</code>.</strong></p>

    <table border="1">
        <thead>
            <tr>
                <th>Full Syntax</th>
                <th>Simplified Syntax</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><pre><code>window.console.log(10)</code></pre><br><pre><code>global.console.log(10)</code></pre><br><pre><code>globalThis.console.log(10)</code></pre></td>
                <td><pre><code>console.log(10)</code></pre></td>
            </tr>
        </tbody>
    </table>
    <hr>

    </div>
    <div>
        <h1>Methods</h1>

        <p>A method is a <strong>property</strong> of an object, which's value is a <strong>function</strong>.</p>

        <h2>Methods VS Properties</h2>

        <table border="1">
            <thead>
                <tr>
                    <th><code>myCity.city</code></th>
                    <th><code>myCity.cityGreeting()</code></th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Accessing value</strong> of a property*</td>
                    <td><strong>Calling</strong> a function</td>
                </tr>
            </tbody>
        </table>

        <p><em>*Accessing value</em> of a <strong>method</strong> returns its <strong>structure</strong>.</p>

        <blockquote>
            <p>If a property that <strong>isn't a method/function is called</strong>, an <strong>error</strong> is thrown: <code>TypeError: ... is not a function</code></p>
        </blockquote>

        <hr>
    </div>
    <div>
        <h1>JSON</h1>

        <p>JSON (<strong><u>J</u>ava <u>S</u>cript <u>O</u>bject <u>N</u>otation</strong>) is a format of <strong>exchange data between computers</strong> over the Web.</p>

        <p>Examples of data represented in JSON:</p>

        <ul>
            <li><em>CSS style tables</em></li>
            <li><em>Images</em></li>
            <li><em>Text files</em></li>
        </ul>

        <h2>JSON Notation</h2>

        <h3>Object Notation</h3>

        <p>JSON objects are commonly used in JavaScript to create objects and are suitable for <strong><em>human</em></strong> readability. They are often referred to as <strong>parsed JSON</strong> when processed in JavaScript.</p>

        <p><strong>Syntax Example:</strong></p>

        <pre><code>{
    "userId":1,
    "id":1,
    "title":"Test Title",
    "Status":{
        "completed": false
    }
}</code></pre>

        <h3>String Notation</h3>

        <p>JSON in string form is typically used for <strong><em>computer</em></strong> readability. It is often referred to as <strong>stringified JSON</strong>. It is often the format that is transferred between systems, and it must be parsed into an object for use in JavaScript.</p>

        <p><strong>Syntax:</strong></p>

        <pre><code>{"userId":1, "id":1, "title":"Test Title", "Status":{"completed": false}}</code></pre>

        <h2>Methods</h2>

        <ul>
            <li><code>JSON.parse()</code>: Transforms <strong>JSON string</strong> into a <strong>JS object</strong>.</li>
            <li><code>JSON.stringify()</code>: Transforms <strong>JS object</strong> into a <strong>JSON string</strong>.</li>
        </ul>
        <hr>
    </div>
    <div>
        <h1>Mutations in JS</h1>

        <p>In JavaScript, <strong>mutation</strong> refers to <strong>changing the state or value of an object or array</strong>. Unlike <strong>primitive values</strong> (such as numbers, strings, and booleans), which are <strong>immutable</strong> (meaning they cannot be changed directly), <strong>objects and arrays are mutable</strong>, meaning their properties and elements <strong>can be altered</strong>.</p>

        <h2>Mutating Object</h2>

        <p>In an object, properties and elements can be <strong>mutated by editing, adding or removing</strong> properties.</p>

        <h3>Examples</h3>

        <h4><em>Editing</em> property mutation:</h4>

        <pre><code>const person = { name: 'Alice', age: 25 };
person.age = 26;  // Mutating the 'age' property of the object
console.log(person.age);  // Output: 26 </code></pre>

        <h4><em>Adding</em> and <em>removing</em> property mutation:</h4>

        <pre><code>const user = { name: 'John' };
user.age = 30;  // Adding a new property to the object
console.log(user);  // Output: { name: 'John', age: 30 }

delete user.name;  // Removing a property from the object
console.log(user);  // Output: { age: 30 } </code></pre>

        <h2>Mutating Array</h2>

        <p>Same as in an object, array can be <strong>mutated by editing, adding and removing</strong> elements and changing array's <strong>length</strong>.</p>

        <h3>Examples</h3>

        <h4><em>Editing</em> and <em>adding</em> property mutation:</h4>

        <pre><code>const numbers = [1, 2, 3];
numbers[0] = 10;  // Mutating the first element of the array
console.log(numbers);  // Output: [10, 2, 3]

numbers.push(4);  // Adding an element to the array
console.log(numbers);  // Output: [10, 2, 3, 4]</code></pre>

        <h4>Editing array <em>length</em> mutation:</h4>

        <pre><code>const fruits = ['apple', 'banana', 'cherry'];
fruits.length = 2;  // Mutating the array by shortening it
console.log(fruits);  // Output: ['apple', 'banana']</code></pre>

        <h2>Mutation Functions</h2>

        <p>In JavaScript, when you pass an object or an array to a <strong>function</strong>, the function has <strong>access to the original object or array</strong> (because objects and arrays are <strong>passed by reference</strong>). If the function mutates the object or array, the <strong>changes will be reflected outside the function as well.</strong></p>

        <h3>Example:</h3>

        <pre><code>function updateName(person) {
    person.name = 'Bob';  // Mutating the object
}

const person = { name: 'Alice' };
updateName(person);
console.log(person.name);  // Output: Bob</code></pre>

        <h2>Avoiding Mutations</h2>

        <p>Example object for this section:</p>

        <pre><code>const person = {
    name: 'Bob',
    age: 21
};</code></pre>

        <h3><code>Object.assign({}, person)</code></h3>
        <p><code>assign</code> - creates a <strong>new</strong> object.<br>
        <code>{}</code> - <strong>writes the value</strong>.<br>
        <code>person</code> - object that needs to be copied.</p>

        <blockquote>
            <p>Con: <strong>Embedded references are still copied.</strong></p>
        </blockquote>

        <h3><code>= {...person}</code></h3>
        <p><code>{______}</code> - creates a new object.<br>
        <code>...</code> - <strong>`Spread`</strong> operator, separating object on properties<br>
        <code>person</code> - object that needs to be copied.</p>

        <blockquote>
            <p>Con: <strong>Embedded references are still copied.</strong></p>
        </blockquote>

        <h3><code>JSON.parse(JSON.stringify(person))</code></h3>
        <p><code>JSON.stringify(person)</code> - Converts the <code>person</code> <em>object to a JSON string</em>.<br>
        <code>JSON.parse()</code> - Parses the <em>JSON string back into a <strong>new</strong> object</em>.</p>

        <blockquote>
            <p>Pro: Embedded references are <strong>NOT</strong> copied.<br>
            Con: <strong>Does not preserve functions or non-JSON data types</strong> (like <code>undefined</code>, <code>RegExp</code>, or <code>Date</code>).</p>
        </blockquote>

        <h2>Summary</h2>

        <table border="1">
            <thead>
                <tr>
                    <th>Avoid method</th>
                    <th>Embedded references?</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>Object.assign({}, person)</code></td>
                    <td>☑️ (Shallow copy)</td>
                </tr>
                <tr>
                    <td><code>= {...person}</code></td>
                    <td>☑️ (Shallow copy)</td>
                </tr>
                <tr>
                    <td><code>JSON.parse(JSON.stringify(person))</code></td>
                    <td>❎ (Deep copy, no functions or non-JSON data)</td>
                </tr>
            </tbody>
        </table>
    <hr>
    </div>
</body>
</html>